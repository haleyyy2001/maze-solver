import resource
__author__ = "[Huilin Tai]"
__email__ = "[ht2666@columbia.edu]"

# ======================================================================#
# *#*#*# Optional: Import any allowed libraries you may need here #*#*#*#
# ======================================================================#
from queue import LifoQueue
from queue import Queue  # Stack implementation
import time
import heapq
import time
# =================================#
# *#*#*# Your code ends here #*#*#*#
# =================================#

import argparse

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='Robot Path Planning | HW 1 | COMS 4701')
    parser.add_argument('-bfs', action="store_true",
                        default=False, help="Run BFS on the map")
    parser.add_argument('-dfs', action="store_true",
                        default=False, help="Run DFS on the map")
    parser.add_argument('-astar', action="store_true",
                        default=False, help="Run A* on the map")
    parser.add_argument('-ida', action="store_true", default=False,
                        help="Run Iterative Deepening A* on the map")
    parser.add_argument('-all', action="store_true",
                        default=False, help="Run all the 4 algorithms")
    parser.add_argument('-m', action="store", help="Map filename")

    results = parser.parse_args()

    if results.m == "" or not (results.all or results.astar or results.bfs or results.dfs or results.ida):
        print("Check the parameters : >> python hw1_UNI.py -h")
        exit()

    if results.all:
        results.bfs = results.dfs = results.astar = results.ida = True

    # Reading of map given and all other initializations
    try:
        with open(results.m) as f:
            arena = f.read()
            arena = arena.split("\n")
    except:
        print("Error in reading the arena file.")
        exit()

    # Internal representation
    print(arena)

    print("The arena of size " + str(len(arena)) + "x" + str(len(arena[0])))
    print("\n".join(arena))


class MazeState:
    '''
    This class is an abstraction to store a maze state, which contains the following:
    - Maze configuration (arena)
    - Current Position (position in the the maze that the current state represents)
    - Parent (the state from which the current state came from)
    - Action (the action taken in the parent state, direction moved, which lead to the creation of the current state)
    - Cost (Cost  of the path taken from the start to the current state)
    - Children (a child of the current state is generated by moving in a direction)
    '''

    def get_start_index(self):
        '''
        Returns the start index of the maze based on the given arena
        returns (-1, -1) if no start index found
        '''
        for i, row in enumerate(self.arena):
            if 's' in row:
                return (i, row.index('s'))
        return (-1, -1)
        # =======================================================================#
        # *#*#*# TODO: Write your code to find the start index of the maze #*#*#*#
        # =======================================================================#

        # return None
        # =================================#
        # *#*#*# Your code ends here #*#*#*#
        # =================================#

    def get_goal_index(self):
        '''
        Returns the goal index of the maze based on the given arena
        returns (-1, -1) if no goal index found
        '''
        for i, row in enumerate(self.arena):
            if 'g' in row:
                return (i, row.index('g'))
        return (-1, -1)
        # ======================================================================#
        # *#*#*# TODO: Write your code to find the goal index of the maze #*#*#*#
        # ======================================================================#

        # return None
        # =================================#
        # *#*#*# Your code ends here #*#*#*#
        # =================================#

    def __init__(self, arena, parent=None, action='Start', cost=0, current_position=(-1, -1)):

        self.arena = arena
        self.parent = parent
        self.action = action
        self.cost = cost
        self.children = []

        self.start = self.get_start_index()
        self.goal = self.get_goal_index()

        if (current_position[0] == -1):
            self.current_position = self.start
        else:
            self.current_position = current_position

    def display(self):
        print("\n".join(self.arena))

    def move_up(self):
        new_row = self.current_position[0] - 1
        new_col = self.current_position[1]
        if new_row >= 0 and self.is_passable(new_row, new_col):
            return MazeState(self.arena, self, action='UP', cost=self.cost + 1,
                             current_position=(new_row, new_col))
        else:
            return None

    def move_down(self):
        new_row = self.current_position[0] + 1
        new_col = self.current_position[1]
        if new_row < len(self.arena) and self.is_passable(new_row, new_col):
            return MazeState(self.arena,  self, action='DOWN', cost=self.cost + 1,
                             current_position=(new_row,  new_col))
        else:
            return None

    def move_left(self):
        new_row = self.current_position[0]

        new_col = self.current_position[1] - 1
        if new_col >= 0 and self.is_passable(new_row, new_col):
            return MazeState(self.arena,  self, action='LEFT', cost=self.cost + 1,
                             current_position=(new_row, new_col))
        else:
            return None

    def move_right(self):
        new_row = self.current_position[0]
        new_col = self.current_position[1] + 1
        if new_col < len(self.arena[new_row]) and self.is_passable(new_row, new_col):
            return MazeState(self.arena, self,  action='RIGHT', cost=self.cost + 1,
                             current_position=(new_row,  new_col))
        else:
            return None

    def is_passable(self,  row, col):
        if col < len(self.arena[row]):
            return self.arena[row][col] != 'o'
        else:
            return False

    # #=================================#
    # 	#*#*#*# Your code ends here #*#*#*#
    # 	#=================================#
    #
    # def move_left(self):
    # 	'''
    # 	This function checks if left is a valid move from the given state.
    # 	If left is a valid move, returns a child in which the player has moved left.
    # 	Else returns None.
    # 	'''
    #

    def expand(self):
        """ 
        Generate the child nodes of this node 
        """

        if (len(self.children) != 0):
            return self.children

        # Do not change the order in this function, since the grading script assumes this order of expansion when checking
        children = [self.move_up(),  self.move_right(),
                    self.move_down(),  self.move_left()]

        self.children = [state for state in children if state is not None]
        return self.children

    def __hash__(self):
        '''
        Maze states hashed based on cost. 
        This function may be modified if required.
        '''
        # ============================================================================================#
        # *#*#*# Optional: May be modified if your algorithm requires a different hash function #*#*#*#
        # ============================================================================================#

        return hash(self.current_position)

    # =================================#
        # *#*#*# Your code ends here #*#*#*#
        # =================================#

    def __eq__(self, other):
        '''
        Maze states are defined as equal if they have the same dimensions and the same current position. 
        This function may be modified if required.
        '''

        # =============================================================================================#
        # *#*#*# Optional: May be modified if your algorithm requires a different equality check #*#*#*#
        # =============================================================================================#

        return self.current_position == other.current_position

        # =================================#
        # *#*#*# Your code ends here #*#*#*#
        # =================================#

    # =====================================================================================#
    # *#*#*# Optional: Write any other functions you may need in the MazeState Class #*#*#*#
    # =====================================================================================#

    # =================================#
    # *#*#*# Your code ends here #*#*#*#
    # =================================#


# ================================================================================#
# *#*#*# Optional: You may write helper functions in this space if required #*#*#*#
# ================================================================================#
def mark_solution_path(state):
    """
    Backtrack from the goal to the start and mark the solution path with stars ('*').
    """
    arena_with_wholepath = [list(row) for row in state.arena]

    # Backtrack from the goal to the start
    current_state = state
    while current_state.parent is not None:
        row, col = current_state.current_position
        if arena_with_wholepath[row][col] not in ('s', 'g'):
            arena_with_wholepath[row][col] = '*'
        current_state = current_state.parent

    # Mark the start position with 's'
    start_row, start_col = state.start
    arena_with_wholepath[start_row][start_col] = 's'

    # Convert
    return ["".join(row) for row in arena_with_wholepath]


# =================================#
# *#*#*# Your code ends here #*#*#*#
# =================================#

'''
This function runs Breadth First Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
'''


def bfs(arena):
    from collections import deque
    import time

    begin_time = time.time()

    start_state = MazeState(arena)

    frontier = deque([start_state])
    explored = set()

    max_nodes_stored = 1
    max_search_depth = 0
    nodes_expanded = 0

    if start_state.start == (-1, -1) or start_state.goal == (-1, -1):
        return [], -1, 0, 0, 0, time.time() - begin_time, 0  # No solution

    while len(frontier) > 0:
        state = frontier.popleft()
        explored.add(state)

        # Check if  reached the goal
        if state.current_position == state.goal:
            solution_path = mark_solution_path(state)  # Path found, mark it
            ram_usage = resource.getrusage(
                resource.RUSAGE_SELF).ru_maxrss / 1024
            return solution_path, state.cost, nodes_expanded, max_nodes_stored, max_search_depth, time.time() - begin_time, ram_usage

        nodes_expanded += 1

        for neighbor in state.expand():  # Expand

            if neighbor not in explored and neighbor not in frontier:
                frontier.append(neighbor)
                # Update max search depth
                max_search_depth = max(max_search_depth, neighbor.cost)

        # Update
        max_nodes_stored = max(max_nodes_stored, len(frontier) + len(explored))

    # If no solution found
    return [], -1, nodes_expanded, max_nodes_stored, max_search_depth, time.time() - begin_time, 0


'''
This function runs Depth First Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
'''


def dfs(arena):
    import time
    import resource

    begin_time = time.time()

    start_state = MazeState(arena)
    frontier = []
    frontier.append(start_state)
    explored = set()

    max_nodes_stored = 1

    max_search_depth = 0
    nodes_expanded = 0

    if (start_state.start == (-1, -1)) or (start_state.goal == (-1, -1)):
        return [], -1, 0, 0, 0, time.time() - begin_time, 0

    while len(frontier) != 0:
        state = frontier.pop()
        explored.add(state)

        if state.current_position == state.goal:
            solution_path = mark_solution_path(state)

            ram_usage = resource.getrusage(
                resource.RUSAGE_SELF).ru_maxrss / 1024
            return (solution_path,  state.cost, nodes_expanded, max_nodes_stored, max_search_depth,  time.time() - begin_time, ram_usage)

        nodes_expanded += 1
        neighbors = state.expand()
        neighbors.reverse()

        for neighbor in neighbors:
            if (neighbor not in explored) and (neighbor not in frontier):
                frontier.append(neighbor)

                max_search_depth = max(max_search_depth, neighbor.cost)

                # max_search_depth = (max_search_depth,)  #
        max_nodes_stored = max(max_nodes_stored, len(frontier) + len(explored))

    return [], -1, nodes_expanded, max_nodes_stored, max_search_depth, time.time() - begin_time, 0


'''
This function runs A* Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
'''


def astar(arena):

    # ================================================#
    # *#*#*# TODO: Write your A* algorithm here #*#*#*#
    # ================================================#
    import heapq
    begin_time = time.time()
    start_state = MazeState(arena)
    frontier = []

    explored = set()
    # max_nodes_stored = 0
    max_nodes_stored = 1
    max_search_depth = 0

    nodes_expanded = 0
    max_search_depth = 0

    if start_state.start == (-1, -1) or start_state.goal == (-1, -1):
        ram_usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / 1024
        return [], -1, 0, 0, 0,  time.time() - begin_time, ram_usage

    def heuristic(state):
        return abs(state.goal[0] - state.current_position[0]) + abs(state.goal[1] - state.current_position[1])
    f_start = start_state.cost+heuristic(start_state)

    heapq.heappush(frontier, (f_start, id(start_state), start_state))
    # Maps positions to the lowest cost to reach them

    cost_so_far = {start_state.current_position: start_state.cost}

    # Main loop
    while frontier:
        _, _, state = heapq.heappop(frontier)
        if state.current_position in explored:
            continue

        explored.add(state.current_position)

        if (state.current_position == state.goal):
            solution_path = mark_solution_path(state)
            ram_usage = resource.getrusage(
                resource.RUSAGE_SELF).ru_maxrss / 1024
            return (solution_path,   state.cost,  nodes_expanded,
                    max_nodes_stored, max_search_depth,
                    time.time() - begin_time, ram_usage)

        nodes_expanded += 1

        for neighbor in state.expand():
            new_cost = state.cost + 1
            neighbor_position = neighbor.current_position

            if (neighbor_position not in cost_so_far) or (new_cost < cost_so_far[neighbor_position]):
                cost_so_far[neighbor_position] = new_cost

                neighbor.cost = new_cost
                f_neighbor = (new_cost + heuristic(neighbor))
                heapq.heappush(frontier, (f_neighbor, id(neighbor), neighbor))
                max_search_depth = max(max_search_depth, neighbor.cost)

        max_nodes_stored = max(max_nodes_stored, len(frontier) + len(explored))

    # If no solution
    ram_usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / 1024
    return [], -1, nodes_expanded, max_nodes_stored, max_search_depth, time.time() - begin_time, ram_usage
    # =================================#
    # *#*#*# Your code ends here #*#*#*#
    # =================================#


'''
This function runs Iterative Deepening A* Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
'''


def ida(arena):
    import time
    import resource
    import sys

    # Increase the recursion  why it doesnt work??????
    sys.setrecursionlimit(1000000)

    begin_time = time.time()

    start_state = MazeState(arena)

    # invalid start
    if start_state.start == (-1, -1) or start_state.goal == (-1, -1):
        return [], -1, 0, 0, 0, time.time() - begin_time, resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / 1024

    def heuristic(state):
        # Manha
        return (abs(state.goal[0] - state.current_position[0]) + abs(state.goal[1] - state.current_position[1]))

    nodes_expanded = 0

    max_nodes_stored = 1
    max_search_depth = 0

    threshold = heuristic(start_state)

    while True:
        min_threshold = float('inf')
        path = [start_state]

        # def dfs(arena):
        # 	import time
        # 	import resource
        #
        # 	begin_time = time.time()
        #
        # 	start_state = MazeState(arena)
        # 	frontier = []
        # 	frontier.append(start_state)
        # 	explored = set()
        #
        # 	max_nodes_stored = 1
        #
        # 	max_search_depth = 0
        # 	nodes_expanded = 0
        #
        # 	if (start_state.start == (-1, -1)) or (start_state.goal == (-1, -1)):
        # 		return [], -1, 0, 0, 0, time.time() - begin_time, 0
        #
        # 	while len(frontier) != 0:
        # 		state = frontier.pop()
        # 		explored.add(state)
        #
        # 		if state.current_position == state.goal:
        # 			solution_path = mark_solution_path(state)
        #
        # 			ram_usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / 1024
        # 			return (solution_path, state.cost, nodes_expanded, max_nodes_stored, max_search_depth,
        # 					time.time() - begin_time, ram_usage)
        #
        # 		nodes_expanded += 1
        # 		neighbors = state.expand()
        # 		neighbors.reverse()
        #
        # 		for neighbor in neighbors:
        # 			if (neighbor not in explored) and (neighbor not in frontier):
        # 				frontier.append(neighbor)
        #
        # 				max_search_depth = max(max_search_depth, neighbor.cost)  #
        #
        # 		# max_search_depth = (max_search_depth,)  #
        # 		max_nodes_stored = max(max_nodes_stored, len(frontier) + len(explored))
        #
        # 	return [], -1, nodes_expanded, max_nodes_stored, max_search_depth, time.time() - begin_time, 0

        def dfs(state, g):

            nonlocal nodes_expanded, max_nodes_stored, max_search_depth, min_threshold

            nodes_expanded += 1
            f = g + heuristic(state)
            if f > threshold:
                if f < min_threshold:
                    min_threshold = f
                return False

            if state.current_position == state.goal:
                return True  # Goal found

            if len(path) > max_nodes_stored:
                max_nodes_stored = len(path)
            if g > max_search_depth:
                max_search_depth = g

            for neighbor in state.expand():
                path.append(neighbor)

                if dfs(neighbor, g + 1):
                    return True
                path.pop()

            return False

            # ram_usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
        found = dfs(start_state, 0)
        if found:
            solution_path = mark_solution_path(path[-1])
            ram_usage = resource.getrusage(
                resource.RUSAGE_SELF).ru_maxrss / 1024
            return (solution_path, len(path) - 1, nodes_expanded, max_nodes_stored, max_search_depth + 1,
                    time.time() - begin_time, ram_usage)

        if min_threshold == float('inf'):

            ram_usage = resource.getrusage(
                resource.RUSAGE_SELF).ru_maxrss / 1024
            # ram_usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss

            return [], -1, nodes_expanded, max_nodes_stored, max_search_depth + 1, time.time() - begin_time, ram_usage

        threshold = min_threshold

        # =================================================#
        # *#*#*# TODO: Write your IDA algorithm here #*#*#*#
        # =================================================#

        # =================================#
        # *#*#*# Your code ends here #*#*#*#
        # =================================#


if __name__ == "__main__":
    if results.bfs:
        print("\nBFS algorithm called")
        bfs_arena, bfs_cost, bfs_nodes_expanded, bfs_max_nodes_stored, bfs_max_search_depth, bfs_time, bfs_ram = bfs(
            arena)
        print("\n".join(bfs_arena))
        print("BFS:")
        print("Cost: " + str(bfs_cost))
        print("Nodes Expanded: " + str(bfs_nodes_expanded))
        print("Max Nodes Stored: " + str(bfs_max_nodes_stored))
        print("Max Search Depth: " + str(bfs_max_search_depth))
        print("Time: " + str(bfs_time) + "s")
        print("RAM Usage: " + str(bfs_ram) + "kB\n")

    if results.dfs:
        print("\nDFS algorithm called")
        dfs_arena, dfs_cost, dfs_nodes_expanded, dfs_max_nodes_stored, dfs_max_search_depth, dfs_time, dfs_ram = dfs(
            arena)
        print("\n".join(dfs_arena))
        print("DFS:")
        print("Cost: " + str(dfs_cost))
        print("Nodes Expanded: " + str(dfs_nodes_expanded))
        print("Max Nodes Stored: " + str(dfs_max_nodes_stored))
        print("Max Search Depth: " + str(dfs_max_search_depth))
        print("Time: " + str(dfs_time) + "s")
        print("RAM Usage: " + str(dfs_ram) + "kB\n")

    if results.astar:
        print("\nA* algorithm called")
        astar_arena, astar_cost, astar_nodes_expanded, astar_max_nodes_stored, astar_max_search_depth, astar_time, astar_ram = astar(
            arena)
        print("\n".join(astar_arena))
        print("A*:")
        print("Cost: " + str(astar_cost))
        print("Nodes Expanded: " + str(astar_nodes_expanded))
        print("Max Nodes Stored: " + str(astar_max_nodes_stored))
        print("Max Search Depth: " + str(astar_max_search_depth))
        print("Time: " + str(astar_time) + "s")
        print("RAM Usage: " + str(astar_ram) + "kB\n")

    if results.ida:
        print("\nIterative Deepening A* algorithm called")
        ida_arena, ida_cost, ida_nodes_expanded, ida_max_nodes_stored, ida_max_search_depth, ida_time, ida_ram = ida(
            arena)
        print("\n".join(ida_arena))
        print("Iterative Deepening A*:")
        print("Cost: " + str(ida_cost))
        print("Nodes Expanded: " + str(ida_nodes_expanded))
        print("Max Nodes Stored: " + str(ida_max_nodes_stored))
        print("Max Search Depth: " + str(ida_max_search_depth))
        print("Time: " + str(ida_time) + "s")
        print("RAM Usage: " + str(ida_ram) + "kB\n")
